package org.qualiton.service

import cats.data.Chain
import cats.effect.IO
import cats.effect.concurrent.Ref
import cats.implicits._
import org.qualiton.mock.FunctionalMock

//Mock trait needs to be created with all the methods we want mock capability to be genereted for
@FunctionalMock //Addig this macro annotation trigger the code generation
trait MockService[F[_]] extends Service[F] {

  //val service1HistoryRef: Ref[F, Chain[((Int, String), Either[Throwable, Long])]] //generated by macro to be able to get service1 method call history
  //def whenService1(mock: (Int, String) => F[Long]): F[Unit] //generated by macro to be able to add method behaviour for service1
  override def service1(i: Int, s: String): F[Long] //Needs to be added even though inherited from the parent since it is hard for an annotation marco to explore parent Tree

  //val service2HistoryRef: Ref[F, Chain[(String, Either[Throwable, String])]] //generated by macro to be able to get service2 method call history
  //def whenService2(mock: String => F[String]): F[Unit] //generated by macro to be able to add method behaviour for service2
  override def service2(i: String): F[String] //Needs to be added even though inherited from the parent since it is hard for an annotation marco to explore parent Tree

  //def clean(): F[Unit] //generated by macro to be able to clean internal state
}


//MockService companion will be generated by marco. I added it to see what I need to generate. It will be removed after the companion is genereted
object MockServiceManual {
  def apply(): IO[MockService[IO]] =
    for {
      defaultService1HistoryRef <- Ref.of[IO, Chain[((Int, String), Either[Throwable, Long])]](Chain.empty)
      defaultService2HistoryRef <- Ref.of[IO, Chain[(String, Either[Throwable, String])]](Chain.empty)
      defaultService1Mock = (_: Int, _: String) => IO.raiseError(new Throwable("Mock behaviour is not provided for service1!"))
      defaultService2Mock = (_: String) => IO.raiseError(new Throwable("Mock behaviour is not provided for service2!"))
      service1MockRef <- Ref.of[IO, (Int, String) => IO[Long]](defaultService1Mock)
      service2MockRef <- Ref.of[IO, String => IO[String]](defaultService2Mock)
    } yield new MockService[IO] {
      override val service1HistoryRef: Ref[IO, Chain[((Int, String), Either[Throwable, Long])]] = defaultService1HistoryRef
      override val service2HistoryRef: Ref[IO, Chain[(String, Either[Throwable, String])]] = defaultService2HistoryRef

      override def service1(i: Int, s: String): IO[Long] =
        service1MockRef.get
          .flatMap(_.apply(i, s))
          .attempt
          .flatTap(result => service1HistoryRef.update(_.append((i, s) -> result)))
          .rethrow

      override def service2(i: String): IO[String] =
        service2MockRef.get
          .flatMap(_.apply(i))
          .attempt
          .flatTap(result => service2HistoryRef.update(_.append(i -> result)))
          .rethrow

      override def whenService1(mockF: (Int, String) => IO[Long]): IO[Unit] = service1MockRef.set(mockF)

      override def whenService2(mockF: String => IO[String]): IO[Unit] = service2MockRef.set(mockF)

      override def clean(): IO[Unit] =
        service1MockRef.set(defaultService1Mock) >> service2MockRef.set(defaultService2Mock) >>
          service1HistoryRef.set(Chain.empty) >> service2HistoryRef.set(Chain.empty)
    }
}
