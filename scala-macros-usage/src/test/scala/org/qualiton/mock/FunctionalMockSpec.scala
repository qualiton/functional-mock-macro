package org.qualiton.mock

trait Service[F[_]] {
  def service1(i: Int, s: String): F[Long]

  def service2(i: String): F[String]
}

@FunctionalMock
trait MockService[F[_]] extends Service[F] {

  //val service1HistoryRef: Ref[F, Chain[((Int, String), Either[Throwable, Long])]] //generated by macro to be able to get service1 method call history
  //def whenService1(mock: (Int, String) => F[Long]): F[Unit] //generated by macro to be able to add method behaviour for service1
  override def service1(i: Int, s: String): F[Long]

  //val service2HistoryRef: Ref[F, Chain[(String, Either[Throwable, String])]] //generated by macro to be able to get service2 method call history
  //def whenService2(mock: String => F[String]): F[Unit] //generated by macro to be able to add method behaviour for service2
  override def service2(i: String): F[String]

  //def clean(): F[Unit] //generated by macro to be able to clean internal state
}

import cats.data.Chain
import cats.effect.{ IO, Ref }
import cats.implicits._

object MockService {
  def apply(): IO[MockService[IO]] =
    for {
      defaultService1HistoryRef <- Ref.of[IO, Chain[((Int, String), Either[Throwable, Long])]](Chain.empty)
      defaultService2HistoryRef <- Ref.of[IO, Chain[(String, Either[Throwable, String])]](Chain.empty)
      defaultService1Mock        = (_: Int, _: String) => IO.raiseError(new Throwable("Mock behaviour is not provided for service1!"))
      defaultService2Mock        = (_: String) => IO.raiseError(new Throwable("Mock behaviour is not provided for service2!"))
      service1MockRef           <- Ref.of[IO, (Int, String) => IO[Long]](defaultService1Mock)
      service2MockRef           <- Ref.of[IO, String => IO[String]](defaultService2Mock)
    } yield new MockService[IO] {
      override val service1HistoryRef: Ref[IO, Chain[((Int, String), Either[Throwable, Long])]] = defaultService1HistoryRef

      override val service2HistoryRef: Ref[IO, Chain[(String, Either[Throwable, String])]] = defaultService2HistoryRef

      override def service1(i: Int, s: String): IO[Long] =
        service1MockRef.get
          .flatMap(_.apply(i, s))
          .attempt
          .flatTap(result => service1HistoryRef.update(_.append((i, s) -> result)))
          .rethrow

      override def service2(i: String): IO[String] =
        service2MockRef.get
          .flatMap(_.apply(i))
          .attempt
          .flatTap(result => service2HistoryRef.update(_.append(i -> result)))
          .rethrow

      override def whenService1(mockF: (Int, String) => IO[Long]): IO[Unit] = service1MockRef.set(mockF)

      override def whenService2(mockF: String => IO[String]): IO[Unit] = service2MockRef.set(mockF)

      override def clean(): IO[Unit] =
        service1MockRef.set(defaultService1Mock) >> service2MockRef.set(defaultService2Mock) >>
          service1HistoryRef.set(Chain.empty) >> service2HistoryRef.set(Chain.empty)
    }
}

//import org.scalatest.freespec.AnyFreeSpec
//import org.scalatest.matchers.should.Matchers
//import cats.implicits._
//
//class FunctionalMockSpec extends AnyFreeSpec with Matchers {
//  "FunctionalMock" - {
//    "should generate valid mock" in {
//      val test: IO[Unit] = for {
//        mockService <- MockService()
//        _           <- mockService.whenService2(_ => "OK".pure[IO])
//        result      <- mockService.service2("test")
//        _           <- IO(result should ===("OK"))
//      } yield ()
//
//      test.unsafeRunSync()
//    }
//  }
//}
